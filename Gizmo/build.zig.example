// build.zig.example - Gizmo-recommended build configuration
//
// Copy and adapt this file to your project's build.zig

const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});

    // Gizmo: Prefer ReleaseSafe for production (keeps safety checks)
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "your-project",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // Gizmo-recommended settings

    // Keep runtime safety checks even in optimized builds
    // This catches undefined behavior that AI-generated code might introduce
    if (optimize != .Debug) {
        exe.root_module.omit_frame_pointer = false; // Better stack traces
    }

    // Enable all warnings (helps catch issues in AI-generated code)
    // Note: Zig doesn't have a direct equivalent to -Wall, but the
    // compiler is strict by default

    b.installArtifact(exe);

    // Run step
    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const run_step = b.step("run", "Run the application");
    run_step.dependOn(&run_cmd.step);

    // Test step
    const unit_tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    const run_unit_tests = b.addRunArtifact(unit_tests);
    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_unit_tests.step);
}

// Gizmo Notes:
//
// 1. OPTIMIZATION LEVELS:
//    - Debug: Full safety checks, slow (development)
//    - ReleaseSafe: Optimized with safety checks (recommended for production)
//    - ReleaseFast: Maximum speed, no safety checks (use sparingly)
//    - ReleaseSmall: Minimum size, no safety checks
//
// 2. SAFETY CHECKS (enabled by default in Debug and ReleaseSafe):
//    - Bounds checking on array/slice access
//    - Null pointer checks
//    - Integer overflow detection
//    - Alignment checks
//
// 3. FOR AI-ASSISTED DEVELOPMENT:
//    - Always test with ReleaseSafe to catch issues AI might introduce
//    - Use `std.debug.assert()` for invariants (stripped in Release builds)
//    - Use `std.debug.panic()` for unrecoverable errors
//    - Document all allocator usage with OWNERSHIP comments
